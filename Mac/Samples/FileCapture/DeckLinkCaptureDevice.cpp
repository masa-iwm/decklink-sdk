/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "DeckLinkCaptureDevice.h"
#include "DeckLinkConversionVideoFrame.h"

static const BMDPixelFormat kDevicePixelFormat	= bmdFormat10BitYUV;
static const BMDPixelFormat kEncoderPixelFormat	= bmdFormat8BitBGRA;

// DeckLinkCaptureDevice
DeckLinkCaptureDevice::DeckLinkCaptureDevice(com_ptr<IDeckLink>& deckLink) :
m_refCount(1),
m_init(false),
m_statusListener(nullptr),
m_errorListener(nullptr),
m_deviceState(kDeviceIOIdle),
m_deckLink(deckLink),
m_deckLinkInput(nullptr),
m_deckLinkVideoConversion(nullptr),
m_displayMode(bmdModeNTSC),
m_pixelFormat(kDevicePixelFormat),
m_frameDuration(0),
m_timeScale(0),
m_mediaWriter(nullptr),
m_videoInputConnections(bmdVideoConnectionUnspecified),
m_activeVideoInputConnection(bmdVideoConnectionUnspecified),
m_detectFormat(false),
m_supportsFormatDetection(false),
m_videoInputEnabled(false),
m_audioInputEnabled(false),
m_isAvailable(true),
m_lastValidFrameStatus(kCaptureSignalUnknown)
{
	com_ptr<IDeckLinkProfileAttributes>	attributes(IID_IDeckLinkProfileAttributes, m_deckLink);
	if (!m_deckLink || !attributes)
		return;

	attributes->GetString(BMDDeckLinkDisplayName, &m_displayName);
	attributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &m_supportsFormatDetection);
	
	// Enable format detection by default if supported
	m_detectFormat = m_supportsFormatDetection;
	
	m_fileWriterQueue = dispatch_queue_create("CoreMedia file writer queue", nullptr);
}

DeckLinkCaptureDevice::~DeckLinkCaptureDevice()
{
}

HRESULT DeckLinkCaptureDevice::QueryInterface(REFIID iid, LPVOID *ppv)
{
	CFUUIDBytes	iunknown;
	HRESULT		result = E_NOINTERFACE;

	*ppv = NULL;

	iunknown = CFUUIDGetUUIDBytes(IUnknownUUID);
	if (memcmp(&iid, &iunknown, sizeof(REFIID)) == 0)
	{
		*ppv = this;
		AddRef();
		result = S_OK;
	}
	else if (memcmp(&iid, &IID_IDeckLinkInputCallback, sizeof(REFIID)) == 0)
	{
		*ppv = (IDeckLinkInputCallback*)this;
		AddRef();
		result = S_OK;
	}
	else if (memcmp(&iid, &IID_IDeckLinkNotificationCallback, sizeof(REFIID)) == 0)
	{
		*ppv = (IDeckLinkNotificationCallback*)this;
		AddRef();
		result = S_OK;
	}
	else if (memcmp(&iid, &IID_IDeckLinkProfileCallback, sizeof(REFIID)) == 0)
	{
		*ppv = (IDeckLinkProfileCallback*)this;
		AddRef();
		result = S_OK;
	}

	return result;
}

ULONG DeckLinkCaptureDevice::AddRef()
{
	return ++m_refCount;
}

ULONG DeckLinkCaptureDevice::Release()
{
	ULONG newRefValue = --m_refCount;
	if (newRefValue == 0)
	{
		delete this;
		return 0;
	}

	return newRefValue;
}

HRESULT DeckLinkCaptureDevice::VideoInputFormatChanged(BMDVideoInputFormatChangedEvents notificationEvents, IDeckLinkDisplayMode* newDisplayMode, BMDDetectedVideoInputFormatFlags detectedSignalFlags)
{
	BMDPixelFormat pixelFormat = m_pixelFormat;
	
	(void)notificationEvents; // unused

	DeviceError error = kNoError;

	// Since recording is configured for a specific video format, stop recording
	if (getDeviceIOState() == kFileIORunning)
		stopRecording();

	if (notificationEvents & bmdVideoInputColorspaceChanged)
	{
		if (detectedSignalFlags & bmdDetectedVideoInputRGB444)
			pixelFormat = bmdFormat8BitBGRA;
		else if (detectedSignalFlags & bmdDetectedVideoInputYCbCr422)
			pixelFormat = bmdFormat10BitYUV;
		else
		{
			error = kInvalidFormatChangedEvent;
			goto bail;
		}
	}
	if (m_detectFormat &&
		((notificationEvents & bmdVideoInputDisplayModeChanged) ||
		 (pixelFormat != m_pixelFormat)))
	{
		// Restart streams if either display mode or colorspace has changed
		m_deckLinkInput->StopStreams();

		if (m_deckLinkInput->EnableVideoInput(newDisplayMode->GetDisplayMode(), pixelFormat, bmdVideoInputEnableFormatDetection) != S_OK)
		{
			error = kEnableVideoInputFailed;
			goto bail;
		}

		if (m_deckLinkInput->StartStreams() != S_OK)
		{
			error = kStartCaptureFailed;
			goto bail;
		}

		m_displayMode = newDisplayMode->GetDisplayMode();
		m_pixelFormat = pixelFormat;

		notifyStatus(kCaptureFormatChanged);
	}

bail:
	if (error)
	{
		disableVideoInput();
		disableAudioInput();
		setState(kDeviceIOIdle);
		notifyError(error);
	}

	return S_OK;
}

HRESULT	DeckLinkCaptureDevice::VideoInputFrameArrived(IDeckLinkVideoInputFrame* videoFrame, IDeckLinkAudioInputPacket* audioPacket)
{
	if (!videoFrame)
		return S_OK;

	DeviceStatus validFrameStatus = (videoFrame->GetFlags() & bmdFrameHasNoInputSource) != 0 ? kCaptureSignalInvalid : kCaptureSignalValid;

	// Notify changes when the input signal becomes valid (or not)
	if (m_lastValidFrameStatus != validFrameStatus)
		notifyStatus(validFrameStatus);

	// Check we have a valid frame to write
	if (m_deviceState == kFileIORunning && validFrameStatus)
	{
		// Creating com_ptrs from raw COM objects increments their reference counts
		com_ptr<IDeckLinkVideoInputFrame>	deckLinkVideoFrame(videoFrame);
		com_ptr<IDeckLinkAudioInputPacket>	deckLinkAudioPacket(audioPacket);

		// It is important not to block this thread to avoid incoming frames being dropped
		// Hand off video frame writing to a worker queue
		dispatch_async(m_fileWriterQueue, ^{
			writeVideoFrame(deckLinkVideoFrame, deckLinkAudioPacket);
		});
	}

	m_lastValidFrameStatus = validFrameStatus;

	return S_OK;
}

HRESULT DeckLinkCaptureDevice::Notify(BMDNotifications topic, uint64_t param1, uint64_t param2)
{
	if (topic != bmdPreferencesChanged)
		return S_OK;
	
	int64_t activeVideoInputConnection = bmdVideoConnectionUnspecified;
	if (m_deckLinkConfiguration->GetInt(bmdDeckLinkConfigVideoInputConnection, &activeVideoInputConnection) != S_OK)
		return E_FAIL;

	setVideoInputConnection(activeVideoInputConnection);
	return S_OK;
}

HRESULT DeckLinkCaptureDevice::ProfileChanging(IDeckLinkProfile *profileToBeActivated, bool streamsWillBeForcedToStop)
{
	if (!profileToBeActivated)
		return E_FAIL;
	
	if (streamsWillBeForcedToStop)
		disable();
	
	return S_OK;
}

HRESULT DeckLinkCaptureDevice::ProfileActivated(IDeckLinkProfile *activatedProfile)
{
	update();
	return S_OK;
}

bool DeckLinkCaptureDevice::init(std::shared_ptr<DeckLinkMediaWriter> mediaWriter)
{
	com_ptr<IDeckLinkInput>					deckLinkInput(IID_IDeckLinkInput, m_deckLink);
	com_ptr<IDeckLinkConfiguration>			deckLinkConfiguration(IID_IDeckLinkConfiguration, m_deckLink);
	com_ptr<IDeckLinkNotification>			deckLinkNotification(IID_IDeckLinkNotification, m_deckLink);
	
	if (!deckLinkInput || !deckLinkConfiguration)
		return false;
	
	m_deckLinkInput = std::move(deckLinkInput);
	
	// Configuration is member variable to ensure settings persist while the device is connected
	m_deckLinkConfiguration = std::move(deckLinkConfiguration);
	
	if (deckLinkNotification)
		deckLinkNotification->Subscribe(bmdPreferencesChanged, this);	// For video input connection changes

	com_ptr<IDeckLinkProfileManager> profileManager(IID_IDeckLinkProfileManager, m_deckLink);
	if (profileManager)
		profileManager->SetCallback(this);
	
	update();

	if (!m_deckLinkVideoConversion)
	{
		m_deckLinkVideoConversion = CreateVideoConversionInstance();
		if (!m_deckLinkVideoConversion)
			return false;
	}

	m_mediaWriter = mediaWriter;
	m_init = true;

	return m_init;
}

bool DeckLinkCaptureDevice::update()
{
	com_ptr<IDeckLinkProfileAttributes>	deckLinkAttributes(IID_IDeckLinkProfileAttributes, m_deckLink);
	
	if (!deckLinkAttributes)
		return false;
	
	if (deckLinkAttributes->GetInt(BMDDeckLinkVideoInputConnections, &m_videoInputConnections) != S_OK)
		m_videoInputConnections = bmdVideoConnectionUnspecified;
	
	if (m_deckLinkConfiguration->GetInt(bmdDeckLinkConfigVideoInputConnection, &m_activeVideoInputConnection) != S_OK)
		m_activeVideoInputConnection = bmdVideoConnectionUnspecified;
	
	int64_t intVal = 0;
	if (deckLinkAttributes->GetInt(BMDDeckLinkDuplex, &intVal) != S_OK)
		return E_FAIL;
	
	m_isAvailable = (intVal != bmdDuplexInactive);
	
	notifyStatus(kDeviceProfileChanged);
	return true;
}

CFStringRef DeckLinkCaptureDevice::displayName() const
{
	return m_displayName;
}

intptr_t DeckLinkCaptureDevice::getDeviceID() const
{
	return (intptr_t)m_deckLink.get();
}

DeviceIOState DeckLinkCaptureDevice::getDeviceIOState() const
{
	return m_deviceState;
}

void DeckLinkCaptureDevice::setErrorListener(const DeviceErrorOccurredFunc& func)
{
	std::lock_guard<std::mutex> lock(m_mutex);
	m_errorListener = func;
}

void DeckLinkCaptureDevice::setStatusListener(const DeviceStatusUpdateFunc& func)
{
	std::lock_guard<std::mutex> lock(m_mutex);
	m_statusListener = func;
}

void DeckLinkCaptureDevice::notifyStatus(DeviceStatus status)
{
	if (m_statusListener)
		m_statusListener(com_ptr<DeckLinkCaptureDevice>(this), status);
}

void DeckLinkCaptureDevice::notifyError(DeviceError error)
{
	if (m_errorListener)
		m_errorListener(com_ptr<DeckLinkCaptureDevice>(this), error);
}

void DeckLinkCaptureDevice::capture(com_ptr<IDeckLinkScreenPreviewCallback> previewCallback, BMDDisplayMode displayMode)
{
	DeviceError			error			= kNoError;
	BMDVideoInputFlags	videoInputFlags	= m_detectFormat ? bmdVideoInputEnableFormatDetection : bmdVideoInputFlagDefault;

	if (!m_isAvailable || m_deviceState != kDeviceIOIdle)
		return;
	
	m_deckLinkInput->SetScreenPreviewCallback(previewCallback.get());
	m_deckLinkInput->SetCallback(this);

	m_lastValidFrameStatus = kCaptureSignalUnknown;

	if (m_videoInputEnabled)
		disableVideoInput();
	
	enableVideoInput(displayMode, m_pixelFormat, videoInputFlags);
	if (!m_videoInputEnabled)
	{
		error = kEnableVideoInputFailed;
		goto bail;
	}

	if (m_audioInputEnabled)
		disableAudioInput();
	
	enableAudioInput(bmdAudioSampleRate48kHz, m_mediaWriter->audioBitsPerSample(), m_mediaWriter->audioChannelCount());
	if (!m_audioInputEnabled)
	{
		error = kEnableAudioInputFailed;
		goto bail;
	}

	m_displayMode = displayMode;

	if (m_deckLinkInput->StartStreams() != S_OK)
	{
		error = kStartCaptureFailed;
		goto bail;
	}

	setState(kDeviceIORunning);

bail:
	if (error)
	{
		disableVideoInput();
		disableAudioInput();
		setState(kDeviceIOIdle);
		notifyError(error);
	}
}

void DeckLinkCaptureDevice::record(const std::string& filePath)
{
	if (m_deviceState != kDeviceIORunning)
		return;
	
	if (!m_init || m_displayMode == bmdModeUnknown)
	{
		setState(kDeviceIOError);
		return;
	}

	com_ptr<IDeckLinkDisplayMode> deckLinkDisplayMode;
	if (m_deckLinkInput->GetDisplayMode(m_displayMode, deckLinkDisplayMode.releaseAndGetAddressOf()) != S_OK || !deckLinkDisplayMode)
		return;

	if (deckLinkDisplayMode->GetFrameRate(&m_frameDuration, &m_timeScale) != S_OK)
		return;

	// Initialize the media writer for the active display mode
	if (!m_mediaWriter->init(filePath, deckLinkDisplayMode->GetWidth(), deckLinkDisplayMode->GetHeight(), kEncoderPixelFormat, m_frameDuration, m_timeScale))
	{
		setState(kDeviceIORunning);
		return;
	}
	setState(kFileIORunning);
}

void DeckLinkCaptureDevice::stopRecording(bool save)
{
	if (m_deviceState != kFileIORunning || !m_deckLinkInput)
		return;

	if (m_mediaWriter)
		m_mediaWriter->complete(save);

	setState(kDeviceIORunning);

	notifyStatus(kRecordingComplete);
}

void DeckLinkCaptureDevice::disable()
{
	if (m_deviceState == kDeviceIOIdle)
		return;

	stopRecording();
	disableVideoInput();
	disableAudioInput();

	setState(kDeviceIOIdle);
}

void DeckLinkCaptureDevice::setVideoInputConnection(int64_t connection)
{
	if (connection == m_activeVideoInputConnection)
		return;
	
	if (m_deckLinkConfiguration->SetInt(bmdDeckLinkConfigVideoInputConnection, connection) == S_OK)
	{
		// For simplicity capture embedded audio where possible
		m_deckLinkConfiguration->SetInt(bmdDeckLinkConfigAudioInputConnection, bmdAudioConnectionEmbedded);
		
		m_activeVideoInputConnection = connection;
		notifyStatus(kDeviceVideoInputChanged);
	}
}

BMDDisplayMode DeckLinkCaptureDevice::activeDisplayMode() const
{
	return m_displayMode;
}

bool DeckLinkCaptureDevice::formatAutoDetect() const
{
	return m_detectFormat;
}

bool DeckLinkCaptureDevice::supportsFormatAutoDetect() const
{
	return m_supportsFormatDetection;
}

int64_t DeckLinkCaptureDevice::videoInputConnections() const
{
	return m_videoInputConnections;
}

int64_t DeckLinkCaptureDevice::activeVideoInputConnection() const
{
	return m_activeVideoInputConnection;
}

void DeckLinkCaptureDevice::queryDisplayModes(DeckLinkDisplayModeQueryFunc func)
{
	com_ptr<IDeckLinkDisplayModeIterator>	displayModeIterator;
	com_ptr<IDeckLinkDisplayMode>			displayMode;

	std::lock_guard<std::mutex> lock(m_mutex);

	if (m_deckLinkInput->GetDisplayModeIterator(displayModeIterator.releaseAndGetAddressOf()) != S_OK)
		return;

	while (displayModeIterator->Next(displayMode.releaseAndGetAddressOf()) == S_OK)
		func(displayMode);
}

std::string DeckLinkCaptureDevice::filePath() const
{
	if (!m_mediaWriter)
		return std::string();

	return m_mediaWriter->filePath();
}

void DeckLinkCaptureDevice::setState(DeviceIOState deviceState)
{
	m_deviceState = deviceState;
	notifyStatus(kDeviceStateChanged);
}

void DeckLinkCaptureDevice::setFormatAutoDetect(bool enabled)
{
	m_detectFormat = enabled;
}

void DeckLinkCaptureDevice::enableVideoInput(BMDDisplayMode displayMode, BMDPixelFormat pixelFormat, BMDVideoInputFlags flags)
{
	if (m_videoInputEnabled)
		return;

	bool displayModeSupported = true;
	
	if ((m_deckLinkInput->DoesSupportVideoMode((BMDVideoConnection)m_activeVideoInputConnection, displayMode, pixelFormat, bmdNoVideoInputConversion, bmdSupportedVideoModeDefault, NULL, &displayModeSupported) != S_OK)
		|| !displayModeSupported)
		return;

	if (m_deckLinkInput->EnableVideoInput(displayMode, pixelFormat, flags) == S_OK)
		m_videoInputEnabled = true;
}

void DeckLinkCaptureDevice::disableVideoInput()
{
	if (m_videoInputEnabled)
	{
		m_deckLinkInput->StopStreams();
		m_deckLinkInput->DisableVideoInput();
		m_deckLinkInput->SetCallback(nullptr);
		m_deckLinkInput->SetScreenPreviewCallback(nullptr);
		m_videoInputEnabled = false;
	}
}

void DeckLinkCaptureDevice::enableAudioInput(BMDAudioSampleRate sampleRate, BMDAudioSampleType sampleType, uint32_t channelCount)
{
	if (!m_audioInputEnabled && m_deckLinkInput->EnableAudioInput(sampleRate, sampleType, channelCount) == S_OK)
		m_audioInputEnabled = true;
}

void DeckLinkCaptureDevice::disableAudioInput()
{
	if (m_audioInputEnabled)
	{
		m_deckLinkInput->DisableAudioInput();
		m_audioInputEnabled = false;
	}
}

bool DeckLinkCaptureDevice::convertVideoFrame(com_ptr<IDeckLinkVideoInputFrame> sourceFrame, com_ptr<IDeckLinkVideoFrame>& targetFrame)
{
	if (!sourceFrame)
		return false;

	// If the frame is already in the encoder pixel format, 8-bit BGRA, then no conversion is required
	if (sourceFrame->GetPixelFormat() == kEncoderPixelFormat)
	{
		// Reuse (add a reference to) the source input frame (during construction QueryInterface adds a reference)
		targetFrame = com_ptr<IDeckLinkVideoFrame>(IID_IDeckLinkVideoFrame, sourceFrame);
		return true;
	}

	// Convert to encoder pixel format (8-bit BGRA)
	com_ptr<DeckLinkConversionVideoFrame> tempFrame = make_com_ptr<DeckLinkConversionVideoFrame>();
	long width		= sourceFrame->GetWidth();
	long rowBytes	= width * 4; // 8-bit BGRA, refer to SDK manual for other pixel formats

	if (!tempFrame->init(width, sourceFrame->GetHeight(), rowBytes, kEncoderPixelFormat, sourceFrame->GetFlags()))
		return false;

	if (!m_deckLinkVideoConversion || m_deckLinkVideoConversion->ConvertFrame(sourceFrame.get(), tempFrame.get()) != S_OK)
		return false;

	// Set the target frame
	targetFrame = com_ptr<IDeckLinkVideoFrame>(IID_IDeckLinkVideoFrame, tempFrame);
	
	// Release the reference added by QueryInterface during construction
	tempFrame->Release();
	return true;
}

bool DeckLinkCaptureDevice::writeVideoFrame(com_ptr<IDeckLinkVideoInputFrame> deckLinkFrame, com_ptr<IDeckLinkAudioInputPacket> audioPacket)
{
	BMDTimeValue					frameTime	= 0;
	BMDTimeValue					duration	= 0;
	com_ptr<IDeckLinkVideoFrame>	convertedFrame;

	if (!deckLinkFrame)
		goto bail;

	deckLinkFrame->GetStreamTime(&frameTime, &duration, m_timeScale);

	if (!convertVideoFrame(deckLinkFrame, convertedFrame))
		goto bail;

	m_mediaWriter->writeFrame(convertedFrame, frameTime, audioPacket, std::bind(&DeckLinkCaptureDevice::checkWriteResult, this, std::placeholders::_1));
	return true;

bail:
	notifyError(kMediaFileWriteFailed);

	return false;
}

void DeckLinkCaptureDevice::checkWriteResult(WriteResult writeResult)
{
	switch (writeResult)
	{
		case kFrameDropped:
			notifyError(kMediaFileFrameDropped);
			break;
			
		case kFrameError:
			notifyError(kMediaFileWriteFailed);
			break;

		case kFrameComplete:
		case kFrameFlushed:
		default:
			break;
	}
}

bool DeckLinkCaptureDevice::isAvailable() const
{
	return m_isAvailable;
}
