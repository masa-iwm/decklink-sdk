/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */
#pragma once

#include <map>
#include <memory>
#include <mutex>
#include <string>
#include "DeckLinkDeviceState.h"
#include "DeckLinkMediaReader.h"
#include "com_ptr.h"

static const intptr_t kInvalidDevice = 0;

class DeckLinkPlaybackDevice;

typedef std::function<void(com_ptr<DeckLinkPlaybackDevice>, DeviceError)> DeviceErrorOccurredFunc;
typedef std::function<void(com_ptr<DeckLinkPlaybackDevice>, DeviceStatus)> DeviceStatusUpdateFunc;
typedef std::function<void(com_ptr<DeckLinkPlaybackDevice>, DeviceManagerStatus)> DeviceManagerStatusUpdateFunc;
typedef std::function<void(com_ptr<IDeckLinkDisplayMode>&)> DeckLinkDisplayModeQueryFunc;

class DeckLinkPlaybackDeviceDelegate;

class DeckLinkPlaybackDevice : public IDeckLinkVideoOutputCallback, public IDeckLinkAudioOutputCallback, public IDeckLinkProfileCallback
{
public:
	explicit	DeckLinkPlaybackDevice(com_ptr<IDeckLink>& deckLink);
	virtual		~DeckLinkPlaybackDevice();

	// IUnknown
	HRESULT	QueryInterface(REFIID iid, LPVOID *ppv) override;
	ULONG	AddRef() override;
	ULONG	Release() override;

	// IDeckLinkVideoOutputCallback
	HRESULT	ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult result) override;
	HRESULT	ScheduledPlaybackHasStopped() override;

	// IDeckLinkAudioOutputCallback
	HRESULT	RenderAudioSamples(bool preroll) override;
	
	// IDeckLinkProfileCallback
	HRESULT ProfileChanging(IDeckLinkProfile *profileToBeActivated, bool streamsWillBeForcedToStop) override;
	HRESULT ProfileActivated(IDeckLinkProfile *activatedProfile) override;
	
	// Initialization
	bool	init(const std::shared_ptr<DeckLinkMediaReader>& mediaReader);
	bool	update();

	// Device status
	CFStringRef		displayName() const;
	intptr_t		getDeviceID() const;
	DeviceIOState	getDeviceIOState() const;
	void			setErrorListener(const DeviceErrorOccurredFunc& func);
	void			setStatusListener(const DeviceStatusUpdateFunc& func);
	void			notifyStatus(DeviceStatus status);
	void			notifyError(DeviceError error);

	// Playback control
	void		preview(com_ptr<IDeckLinkScreenPreviewCallback> previewCallback, const std::string& filePath, BMDTimeValue streamTime, BMDTimeScale streamTimeScale);
	void		play(BMDTimeValue streamTime, BMDTimeScale timeScale);
	void		scrub(BMDTimeValue streamTime, BMDTimeScale timeScale);
	void		stop(BMDTimeValue streamTime, BMDTimeScale timeScale);
	void		disable();

	// Device status
	std::string	filePath();
	void		queryDisplayModes(DeckLinkDisplayModeQueryFunc func, bool active = false);
	bool		streamTime(BMDTimeValue& streamTime, BMDTimeValue& streamDuration, BMDTimeScale& frameScale);
	void		setState(DeviceIOState deviceState);
	bool		isAvailable() const;

private:
	typedef std::map<BMDDisplayMode, com_ptr<IDeckLinkDisplayMode>> DisplayModeMap;

	// Device control
	void 			enableOutput(com_ptr<IDeckLinkScreenPreviewCallback> previewCallback, BMDDisplayMode displayMode);
	void			disableOutput();
	void			stopScheduledPlayback(BMDTimeValue stopPlaybackAtTime, BMDTimeValue* actualStopTime, BMDTimeScale timeScale);
	bool			convertVideoFrame(com_ptr<IDeckLinkVideoFrame> sourceFrame, com_ptr<IDeckLinkVideoFrame>& targetFrame);
	bool			scheduleVideo();
	bool			scheduleAudio(void* data, uint32_t frameCount);
	BMDDisplayMode	getOutputDisplayMode(float frameRate, long frameWidth, long frameHeight);

	std::atomic<ULONG>						m_refCount;
	bool									m_init;
	std::mutex								m_mutex;
	std::condition_variable					m_condition;
	DeviceStatusUpdateFunc					m_statusListener;
	DeviceErrorOccurredFunc					m_errorListener;
	CFStringRef								m_displayName;
	std::atomic<DeviceIOState>				m_deviceState;
	com_ptr<IDeckLink>						m_deckLink;
	com_ptr<IDeckLinkOutput>				m_deckLinkOutput;
	com_ptr<IDeckLinkVideoConversion>		m_deckLinkVideoConversion;
	float									m_frameRate;
	BMDTimeValue							m_frameDuration;
	BMDDisplayMode							m_videoOutputDisplayMode;
	BMDTimeValue							m_audioStreamTime;
	BMDTimeValue							m_streamTime;
	BMDTimeValue							m_streamTimeOffset;
	BMDTimeScale							m_streamDuration;
	BMDTimeScale							m_timeScale;
	std::shared_ptr<DeckLinkMediaReader>	m_mediaReader;
	bool									m_prerollingAudio;
	bool									m_playbackStopping;
	bool									m_playbackStopped;
	BMDTimeValue							m_lastScheduledFrame;
	std::atomic<bool>						m_isAvailable;
	bool									m_convertToDevicePixelFormat;
};
